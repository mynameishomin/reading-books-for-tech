# 계층형 설계 1

**계층형 설계**는 소프트웨어를 계층으로 구성하는 기술이다.

|                                  |                       |                         |            |                  |
| -------------------------------- | --------------------- | ----------------------- | ---------- | ---------------- |
| 비즈니스 규칙                    | gets_free_shipping()  | cartTax()               |            |                  |
| 장바구니를 위한 동작들           | remove_item_by_name() | calc_total()            | add_item() | setPriceByName() |
| 카피-온-라이트                   | removeItems()         | add_element_item_last() |            |                  |
| 언어에서 지원하는 배열 관련 기능 | .slice()              |                         |            |                  |

각 계층을 정확히 구분하는 것은 어렵다. "가장 좋은 설계"를 위한 절대 공식과 그 공식을 만드는 변수는 많이 있으나 복잡하게 섞여 있어 찾기 힘들다. 설계 감각을 개발하고 그 감각을 따라가면 찾을 수 있을 것이다.

## 설계 감각을 키우기

다음은 계층형 설계를 위한 길잡이로 사용할 수 있는 단서다.

### 계층형 설계 감각을 키우기 위한 입력

| 함수 본문                   | 계층 구조   | 함수 시그니처 |
| --------------------------- | ----------- | ------------- |
| 길이                        | 화살표 길이 | 함수명        |
| 복잡성                      | 응집도      | 인자 이름     |
| 구체화 단계                 | 구체화 단계 | 인잣값        |
| 함수 호출                   |             | 리턴값        |
| 프로그래밍 언어의 기능 사용 |             |               |

### 계층형 설계 감각을 키우기 위한 출력

| 조직화                           | 구현               | 변경                               |
| -------------------------------- | ------------------ | ---------------------------------- |
| 새로운 함수를 어디에 놓을지 결정 | 구현 바꾸기        | 새 코드를 작성할 곳 선택하기       |
| 함수를 다른 곳으로 이동          | 함수 추출하기      | 적절한 수준의 구체화 단계 결정하기 |
|                                  | 데이터 구조 바꾸기 |                                    |

## 계층형 설계 패턴

계층형 설계 패턴 중 가장 중요한 네 가지 패턴은 아래와 같다.

-   직접 구현  
    직접 구현된 함수를 읽을 때 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결한다.

-   추상화 벽  
    인터페이스를 사용하여 코드를 만들면 높은 차원으로 생각할 수 있다. 고수준의 추상화 단계만 생각하면 되기 때문에 두뇌 용량의 한계를 극복할 수 있다.

-   작은 인터페이스  
    비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성한다. 다른 동작도 직간접적으로 최소한의 인터페이스를 유지하면서 정의해야한다.

-   편리한 계층  
    소프트웨어를 더 빠르고 고품질로 제공하는 데 도움이 되는 계층에 시간을 투자해야한다. 그냥 좋아서 계층을 추가하면 안되고 코드와 그 코드가 속한 추상화 계층은 작업할 때 편리해야한다.

먼저 직접 구현에 대해 알아보자.

## 패턴1 직접 구현

아래 코드는 MegaMart에서 넥타이를 사면 클립 하나를 무료로 주는 코드이다.

```javascript
function freeTieClip(cart) {
    const hasTie = false;
    const hasTieClip = false;
    for (let i = 0; i < cart.length; i++) {
        const item = cart[i];
        if (item.name === "tie") {
            hasTie = true;
        }
        if (item.name === "tie clip") {
            hasTieClip = true;
        }
    }
    if (hasTie && !hasTieClip) {
        const tieClip = make_item("tie clip", 0);
        return add_item(cart, tieClip);
    }
    return cart;
}
```

이 코드는 장바구니를 돌면서 항목을 체크하고 무언가를 결정한다. 이건 제대로 설계하지 않고 그냥 기능을 추가한 것이다. 이렇게 코드를 바로 추가하면 유지보수하기 어렵다.

### 장바구니가 해야 할 동작

아래는 장바구니에 필요한 동작이다. 이미 구현한 것은 체크 표시를 했다.

-   ✓ 제품 추가하기
-   ✓ 제품 삭제하기
-   장바구니에 제품이 있는지 확인하기
-   ✓ 함계 계산하기
-   장바구니 비우기
-   ✓ 제품 이름으로 가격 설정하기
-   ✓ 무료 배송이 되는지 확인하기

여기서 장바구니에 제품이 있는지 확인하기를 구현하면 위에서 만들었던 `freeTieClip`함수 안에서 반복문을 돌 필요 없이 명확하게 개선 할 수 있을 것이다.

```javascript
function freeTieClip(cart) {
    const hasTie = isInCart(cart, "tie");
    const hasTieClip = isInCart(cart, "tie clip");

    if (hasTie && !hasTieClip) {
        const tieClip = make_item("tie clip", 0);
        return add_item(cart, tieClip);
    }
    return cart;
}

function isInCart(cart, name) {
    for (let i = 0; i < cart.length; i++) {
        if (cart[i].name === name) {
            return true;
        }
    }
    return false;
}
```

개선하기 전 `freeTieClip`함수가 사용하는 다른 함수와 언어 기능을 보면

| 언어 기능   | 함수 호출   |
| ----------- | ----------- |
| array index | make_item() |
| for loop    | add_item()  |

이렇게 된다. 이때 언어 기능과 함수 호출은 서로 추상화 단계가 다른데 반복문과 배열 인덱스를 참조하는 기능은 함수 호출보다 더 낮은 추상화 단계이다. 한 함수에서 서로 다른 추상화 단계를 사용하면 코드가 명확하지 않고 읽기 어렵다. 직접 구현 패턴은 한 함수 안에서 비슷한 추상화 단계를 사용해야 하므로 이는 직접 구현 패턴이라고 보기 어렵지만 개선한 `freeTieClip`함수 안에서는 서로 비슷한 추상화 단계를 사용하고 있다.

| 함수 호출   |
| ----------- |
| isIncart()  |
| make_item() |
| add_item()  |

`freeTieClip` 함수를 포함해서 내부 모든 함수들이 인자 `cart`가 배열인지 몰라도 된다. 이는 서로 비슷한 계층에 있다는 것을 의미한다.
